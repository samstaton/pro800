<!DOCTYPE html>
<!-- With thanks to https://arachsys.github.io/webmidi/
--> 
<html>
<head>
  <meta charset="utf-8">
  <meta name="author" content="Chris Webb, chris@arachsys.com">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pro 800 Patch Data</title>

<script>
// Remember the current patch number, firmware, device/patch sysex byte arrays
  patch = [];
  firmware = "";
  deviceSysex = [];
patchSysex = [];
patchData = [];

// Crucial function.
// Converts array of 7-bit data (sysex encoded bytes)
// into array of 8-bit bytes, using the Pro 800 encoding
  function midiToBytes(data) {
    bytes = [];
// i: index into data
// j: index into bytes
    j = 0; 
    for (i = 0; i < data.length - 1; i++) {
      if (i % 8 == 0) {
        for (k = 0; k < 7; k++) {
          if (i + k + 1 < data.length - 1) {
            bytes[j + k] = ((data[i] >> k) & 1) << 7;
          }
        }
      } else {
        bytes[j] += data[i];
        j++;
      }
    };
    return bytes;
  }

// The inverse: converts an array of 8-bit bytes
// to an array of 7-bit data for sysex
function bytesToMidi(bytes) {
data = [];
// i: index into data
// j: index into bytes
i=0;
for(j=0;j<bytes.length;j+=7) {
data[i]=0;
for(k=0;k<7;k++) {
if(j+k<bytes.length) 
{data[i]+=(((bytes[j+k] >> 7) & 1) << k);
data[i+k+1]=bytes[j+k] & 0x7F;}
}
i+=8;
}
return data;
}


function changeName() {
var newName = prompt("New patch name. WARNING: sysex for rename will be sent to device : ", patchName);
var utf8 = unescape(encodeURIComponent(newName));

var nameBytes = [];
for (var i = 0; i < utf8.length; i++) {
    nameBytes.push(utf8.charCodeAt(i));
}
if(newName == null) return;
newPatchData = patchData.slice(0,0x96);
newPatchData.push(...nameBytes);
newPatchData.push(...patchData.slice(0x96 + patchData.slice(0x96).indexOf(0)));
patchData = newPatchData;
newPatchSysex = new Uint8Array(12+(bytesToMidi(patchData)).length);
newPatchSysex.set(patchSysex.slice(0,11));
newPatchSysex.set(bytesToMidi(patchData),11);
newPatchSysex[11+(bytesToMidi(patchData)).length]=0xF7;
patchSysex=newPatchSysex;
jobs.push(x => {refreshInfo();})
transmit(patchSysex);
}


// Midi set up from arachsys webmidi
async function midi(rxchooser, txchooser, receive) {
  let access, input, output;

  try {
    access = await navigator.requestMIDIAccess({
      sysex: true
    });
  } catch {
    return null;
  }

  rxchooser = rxchooser(function(id) {
    if (input && input.id != id && receive)
      input.removeEventListener("midimessage", receive);
    input = access.inputs.get(id);
    if (input && receive)
      input.addEventListener("midimessage", receive);
  });

  txchooser = txchooser(function(id) {
    output = access.outputs.get(id);
  });

  access.addEventListener("statechange", function(event) {
    const id = event.port.id,
      state = event.port.state;
    const name = state == "connected" ? event.port.name : null;
    if (event.port.type == "input")
      rxchooser(id, name);
    else if (event.port.type == "output")
      txchooser(id, name);
  });

  access.inputs.forEach(port => rxchooser(port.id, port.name));
  access.outputs.forEach(port => txchooser(port.id, port.name));
  return data => output && output.send(data);
}

// Midi choosers set up from arachsys webmidi
function chooser(select) {
  select = document.getElementById(select);
  return function(choose) {
    select.onchange = event => choose(select.value);
    return function(id, name) {
      for (let option = 0; option < select.length; option++)
        if (select.options[option].value == id) {
          if (name) {
            if (select.options[option].text != name)
              select.options[option].text = name;
            return;
          }
          select.options[option].remove(option);
        }
      if (name) {
        const option = document.createElement("option");
        option.value = id;
        option.text = name;
        select.add(option);
      }
      choose(select.value);
    };
  };
}

// Shell from arachsys webmidi
// This is for the midi hex console
function shell(container, handler) {
  const input = document.createElement("input");
  const prompt = document.createElement("p");
  let history = [],
    buffer = [""],
    index = 0;

  function print(message, color, fixedwidth = false) {
    line = document.createElement("p");
    line.textContent = message;
    line.style.color = color;
    line.style.whiteSpace = "pre-wrap";
    container.insertBefore(line, prompt);
    prompt.scrollIntoView();
  };

  input.setAttribute("autofocus", "true");
  input.setAttribute("spellcheck", "false");
  input.style.margin = input.style.padding = 0;
  input.style.border = input.style.outline = 0;
  input.style.flex = 1;
  input.style.font = "inherit";

  prompt.innerHTML = "&gt;&nbsp;";
  prompt.style.display = "flex";
  prompt.appendChild(input);
  container.appendChild(prompt);

  input.addEventListener("keydown", event => {
    if (event.key == "Enter") {
      print("> " + input.value, null);
      if (input.value.trim()) {
        history.push(input.value);
        if (handler)
          handler(input.value);
      }
      input.value = "";
      buffer = history.concat([""]);
      index = history.length;
    } else if (event.key == "ArrowUp") {
      buffer[index] = input.value;
      if (index > 0)
        input.value = buffer[--index];
      event.preventDefault();
    } else if (event.key == "ArrowDown") {
      buffer[index] = input.value;
      if (index + 1 < buffer.length)
        input.value = buffer[++index];
      event.preventDefault();
    }
  });

  for (type of ["focus", "keypress", "paste"])
    window.addEventListener(type, event => input.focus());
  return print;
}

// Global variables, populated when DOMContentLoaded
  let log;
  let info;
  let shellprint;
  let error;
  let transmit;

  // For midi hex console
  function send(line) {
    const words = line.split(/\s+/).filter(Boolean);
    if (words[0] == "clear") {
      while (log.childNodes.length > 1)
        log.removeChild(log.firstChild);
      return;
    }

    const bytes = words.map(x => Number("0x" + x));
    if (bytes.some(x => isNaN(x) || x > 0xff))
      return error("Invalid byte sequence: " + line.trim());
    else if (bytes[0] & 0x80 == 0)
      return error("Commands must start with a status byte");
    else if (bytes[0] == 0xf0 && bytes[bytes.length - 1] != 0xf7)
      return error("System exclusive messages must end with f7");

    try {
      if (transmit && bytes.length > 0)
        transmit(bytes);
    } catch {
      error("Invalid MIDI command: " + line.trim());
    }
  }

// What to do when a MIDI event is received,
// Either jobs is populated, in which case we dequeue a job
// Or we print the result to the midi hex console.
  function receive(event) {
    if (jobs.length == 0) {
      const filter = document.getElementById("filter").value;
      if (filter != "exclusive" || event.data[0] == 0xf0)
        if (filter != "common" || event.data[0] < 0xf8)
          shellprint(event.data.reduce(function(s, x) {
            return s + " " + x.toString(16).padStart(2, "0");
          }, "").slice(1), "green");
    } else {
      f = jobs.shift();
      f(event.data);
    }
    if (event.data[0] == 0xb0) {
      refreshInfo()
    }
  }

// Handy utility.
// Converts a string of hex digits, separated by spaces, to an array of bytes.
  function strToBytes(str) {
    const words = str.split(/\s+/).filter(Boolean);
    const bytes = words.map(x => Number("0x" + x));
    return bytes;
  }

// The converse.
// Convert array of bytes to space-separated hex string
  bytesToStr = x => x.reduce(function(s, z) {
    if (s == "") {
      return z.toString(16).padStart(2, "0");
    } {
      return s + " " + z.toString(16).padStart(2, "0");
    }
  }, "");


// Queue of handlers for upcoming midi messages
  jobs = [];


// Known parameters in Pro 800 Midi Sysex, in order.
// From https://github.com/samstaton/pro800/blob/main/pro800syx.md
  params = ["Freq A", "Vol A", "PWA", "Freq B", "Vol B", "PWB", "Fine B", "Cutoff", "Res", "Filt Env", "FE R", "FE S", "FE D", "FE A", "AE R", "AE S", "AE D", "AE A", "PM Env", "PM OscB", "LFO Freq", "LFO Amt", "Glide", "Amp Vel", "Filt Vel", "Saw A", "Tri A", "Sqr A", "Saw B", "Tri B", "Sqr B", "Sync", "PM Freq", "PM Filt", "LFO Shape", "???", "LFO Target", "KeyTrk", "FE Shape", "FE Speed", "AE Shape", "NonUnison", "AE Speed"];


// Array of possible lfo targets
  lfoTargets = [];
  for (var i = 0; i <= 63; i++) {
    lfoTargets.push(i.toString(2).padStart(6, "0"));
  }


// Assign each parameter its type.
// 0: A continuous two-byte parameter
// 1: One-byte parameter that is actually just either off or on.
// List: One-byte parameter that could be anything in the list, encoded as a number.
  paramType = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, ["Pulse", "Tri", "Rand", "Sin", "Noise", "Saw"], 1, lfoTargets, ["Off", "Half", "Full"],
    ["Lin", "Exp"],
    ["Fast", "Slow"],
    ["Lin", "Exp"], 1, ["Fast", "Slow"]
  ];


// Display the patch information in the info box
  function updateInfo() {
    info.innerHTML = "";
    // data seems to start at position 11 in the sysex data 
    patchData = midiToBytes(patchSysex.slice(11, patchSysex.length));
    // patch name is position 105
    patchName = String.fromCharCode.apply(String, patchData.slice(0x96, 0x96 + patchData. slice(0x96).indexOf(0)));

    // Helper to display a patch heading
    function printInfo(str) {
      line = document.createElement("p");
      line.textContent = str;
      line.style.fontWeight = "bold";
      info.appendChild(line);
    }

    // Helper to display a patch heading
    function printHtml(str) {
      line = document.createElement("p");
      line.innerHTML = str;
      line.style.fontWeight = "bold";
      info.appendChild(line);
    }

    // Helper to display a hex data
    function dumpInfo(str) {
      line = document.createElement("PRE");
      line.textContent = str;
      line.style.color = "green";
      line.style.whiteSpace = "pre-wrap";
      info.appendChild(line);
    }

    printHtml("<b>Current patch: " + (patch[1] * 0x80 + patch[0]).toString(10).padStart(3, "0") + " \"" + patchName + "\"" + " <a href=\"javascript:changeName()\">[rename]</a>");

    // Create table with parameters. 
    table = document.createElement("table");
    k = 5; // known params start from byte index 5
    for (i = 0; i < params.length; i += 6) {
      row = table.insertRow();
      for (j = 0; j < 6; j++) {
        cell = row.insertCell();
        if (i + j < params.length) {
          switch (paramType[i + j]) {
            case 0: // continuous 2-byte param
              text = document.createTextNode(params[i + j] + ": " + (100 * ((patchData[k + 1] * 0x100 + patchData[k]) / (0xFFFF))).toFixed(1).toString(10) + "%  ");
              k += 2;
              break;
            case 1: // 1-byte param, on off
              text = document.createTextNode(params[i + j] + ": " + (patchData[k] ? "off" : "on") + " ");
              k++;
              break;
            default: // 1-byte param, value from list
              text = document.createTextNode(params[i + j] + ": " + paramType[i + j][patchData[k]]);
              k++;
          };
          cell.appendChild(text);
        }
      }
    }
    info.appendChild(table);
    printInfo("Decoded patch data:");
    dumpInfo(bytesToStr(patchData));
    printInfo("Patch system exclusive data:");
    dumpInfo(bytesToStr(patchSysex));
    printInfo("Device system exclusive data:");
    dumpInfo(bytesToStr(deviceSysex));
    printInfo("Firmware version: "+ firmware);
  }

  // Retrieve information from Pro 800 using sysex.
  // We do this by pushing a sequence of jobs.
  function refreshInfo() {
    jobs.push(
      x => {
        firmware = x[10].toString(10) + "." + x[11].toString(10) + "." + x[12].toString(10);
        transmit(strToBytes("F0 00 20 32 00 01 24 00 77 7E 03 F7"));
      });

    jobs.push(
      x => {
        patch = [x[17], x[18]];
        deviceSysex = x;
        transmit(strToBytes("F0 00 20 32 00 01 24 00 77 " + patch[0].toString(16).padStart(2, "0") + " " + patch[1].toString(16).padStart(2, "0") + " F7"));
      });

    jobs.push(x => {
      patchSysex = x;
      updateInfo()
    });

    transmit(strToBytes("F0 00 20 32 00 01 24 00 08 00 F7"));
  }



// Main Event Listener
document.addEventListener("DOMContentLoaded", async function() {


  log = document.getElementById("shell");
  info = document.getElementById("info");
  shellprint = shell(log, send);
  error = message => shellprint(message, "red");
  transmit = await midi(chooser("rx"), chooser("tx"), receive);

  error("Warning: Experimental code based on undocumented midi spec.");
  error("Use at own risk.");

  if (transmit == null)
    return error("Web MIDI not supported or port access refused");
  if (document.getElementById("rx").childNodes.length == 0)
    error("Warning: no MIDI inputs found");
  if (document.getElementById("tx").childNodes.length == 0)
    error("Warning: no MIDI outputs found");

  refreshInfo();


});

  </script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      display: flex;
      flex-direction: column;
overflow-y: hidden;
font-family: system-ui, sans-serif;
padding: 4px;
margin: 4px;
flex:1;
    }

    header {
      display: flex;
      border-bottom: 1px solid #ddd;
      padding: 4px;
      font-family: system-ui, sans-serif;
    }

    header > * {
      margin: 4px;
    }

    header #title {
      flex: 1;
      color: inherit;
      font-weight: bold;
      text-decoration: inherit;
    }

    header select:empty {
      visibility: hidden;
    }

    td {      flex: 1;
      padding: 8px;       overflow-y: auto;

}
    main {    flex: 2;
      padding: 0 8px;       overflow-y: auto;

}
    editor {30%;
      flex: 1;
      padding: 0 8px;
      font-family: monospace;
      overflow-y: auto;
    }
  </style>
</head>

<body>
  <header>
    <a href="https://github.com/samstaton/pro800" id="title">
      Pro 800 Patch Viewer
    </a>
    <select id="rx" title="MIDI Receive Port"></select>
    <select id="tx" title="MIDI Transmit Port"></select>
    <select id="filter" title="Display Filter">
      <option value="exclusive">System Exclusive</option>
      <option value="common">Channel &amp; Common</option>
      <option value="realtime">All Messages</option>
    </select>
    </header>
    <main id="info"></main>
    <hr>
    MIDI hex console:
  <editor id="shell"></editor>
</body>
</html>
